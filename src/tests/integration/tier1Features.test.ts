/**
 * Tier 1 Features Integration Tests
 *
 * Tests for the core features exposed to the UI in Tier 1:
 * 1. Coach Management Actions
 * 2. Depth Chart Management
 * 3. Owner Relations and Patience
 * 4. Contract Management
 *
 * These tests verify that features work correctly and types are valid.
 */

import { CoachActionValidation } from '../../core/coaching/CoachManagementActions';
import {
  DepthChart,
  DepthChartEntry,
  swapPlayers,
  getDepthLabel,
  getPositionDisplayName,
} from '../../core/roster/DepthChartManager';
import { createOwnerViewModel, createDefaultOwner, OwnerViewModel } from '../../core/models/owner';
import {
  createPatienceMeterState,
  createPatienceViewModel,
  PatienceMeterState,
  PatienceViewModel,
} from '../../core/career/PatienceMeterManager';
import {
  calculateDeadMoney,
  getCutBreakdown,
  isExpiringContract,
  createMinimumContract,
} from '../../core/contracts';
import { Position } from '../../core/models/player/Position';

describe('Tier 1 Features Integration', () => {
  describe('Coach Management Actions', () => {
    it('should validate coach action results structure', () => {
      const validation: CoachActionValidation = {
        canPerform: true,
        warning: 'Test warning',
      };

      expect(validation.canPerform).toBe(true);
      expect(validation.warning).toBe('Test warning');
      expect(validation.reason).toBeUndefined();
    });

    it('should validate extension eligibility check structure', () => {
      const validation: CoachActionValidation = {
        canPerform: false,
        reason: 'Contract extension only available with 2 or fewer years remaining',
      };

      expect(validation.canPerform).toBe(false);
      expect(validation.reason).toContain('2 or fewer years');
    });

    it('should validate firing validation structure', () => {
      const validation: CoachActionValidation = {
        canPerform: true,
        warning: 'Firing will result in $5.0M dead money',
      };

      expect(validation.canPerform).toBe(true);
      expect(validation.warning).toContain('dead money');
    });

    it('should validate promotion validation structure', () => {
      const validation: CoachActionValidation = {
        canPerform: false,
        reason: 'You must release the current head coach first',
      };

      expect(validation.canPerform).toBe(false);
      expect(validation.reason).toContain('head coach');
    });
  });

  describe('Depth Chart Management', () => {
    it('should create valid depth chart entry', () => {
      const entry: DepthChartEntry = {
        position: Position.QB,
        playerId: 'player-1',
        depth: 1,
      };

      expect(entry.position).toBe(Position.QB);
      expect(entry.playerId).toBe('player-1');
      expect(entry.depth).toBe(1);
    });

    it('should create valid depth chart structure', () => {
      const depthChart: DepthChart = {
        teamId: 'team-1',
        entries: [
          { position: Position.QB, playerId: 'qb-1', depth: 1 },
          { position: Position.QB, playerId: 'qb-2', depth: 2 },
          { position: Position.RB, playerId: 'rb-1', depth: 1 },
        ],
        autoGenerated: true,
        lastUpdated: Date.now(),
      };

      expect(depthChart.teamId).toBe('team-1');
      expect(depthChart.entries.length).toBe(3);
      expect(depthChart.autoGenerated).toBe(true);
    });

    it('should get depth label correctly', () => {
      expect(getDepthLabel(1)).toBe('Starter');
      expect(getDepthLabel(2)).toBe('Backup');
      expect(getDepthLabel(3)).toBe('3rd String');
    });

    it('should get position display name correctly', () => {
      expect(getPositionDisplayName(Position.QB)).toBe('Quarterback');
      expect(getPositionDisplayName(Position.RB)).toBe('Running Back');
      expect(getPositionDisplayName(Position.WR)).toBe('Wide Receiver');
    });

    it('should swap players in depth chart', () => {
      const depthChart: DepthChart = {
        teamId: 'team-1',
        entries: [
          { position: Position.QB, playerId: 'qb-1', depth: 1 },
          { position: Position.QB, playerId: 'qb-2', depth: 2 },
        ],
        autoGenerated: false,
        lastUpdated: Date.now(),
      };

      const swapped = swapPlayers(depthChart, 'qb-1', 'qb-2');

      const qb1Entry = swapped.entries.find((e: DepthChartEntry) => e.playerId === 'qb-1');
      const qb2Entry = swapped.entries.find((e: DepthChartEntry) => e.playerId === 'qb-2');

      expect(qb1Entry?.depth).toBe(2);
      expect(qb2Entry?.depth).toBe(1);
    });
  });

  describe('Owner Relations', () => {
    it('should create owner with valid structure', () => {
      const owner = createDefaultOwner('owner-1', 'team-1');

      expect(owner.id).toBe('owner-1');
      expect(owner.teamId).toBe('team-1');
      expect(owner.firstName).toBeDefined();
      expect(owner.lastName).toBeDefined();
      expect(owner.personality).toBeDefined();
      expect(owner.patienceMeter).toBeDefined();
      expect(typeof owner.patienceMeter).toBe('number');
    });

    it('should create owner view model with no raw numbers exposed', () => {
      const owner = createDefaultOwner('owner-1', 'team-1');
      owner.firstName = 'Robert';
      owner.lastName = 'Johnson';
      owner.patienceMeter = 75;

      const viewModel = createOwnerViewModel(owner);

      expect(viewModel.id).toBe('owner-1');
      expect(viewModel.fullName).toBe('Robert Johnson');
      expect(viewModel.jobSecurityStatus).toBeDefined();

      // Check that descriptions are strings, not numbers
      expect(typeof viewModel.patienceDescription).toBe('string');
      expect(typeof viewModel.spendingDescription).toBe('string');
      expect(typeof viewModel.controlDescription).toBe('string');
      expect(typeof viewModel.loyaltyDescription).toBe('string');
    });

    it('should map patience meter to job security status', () => {
      const testCases = [
        { patience: 85, expected: 'secure' },
        { patience: 55, expected: 'stable' },
        { patience: 40, expected: 'warm seat' },
        { patience: 25, expected: 'hot seat' },
        { patience: 10, expected: 'danger' },
      ];

      testCases.forEach(({ patience, expected }) => {
        const owner = createDefaultOwner('owner-test', 'team-1');
        owner.patienceMeter = patience;

        const viewModel = createOwnerViewModel(owner);
        expect(viewModel.jobSecurityStatus).toBe(expected);
      });
    });
  });

  describe('Patience Meter', () => {
    it('should create patience meter state', () => {
      const state = createPatienceMeterState('owner-1', 50, 1, 1);

      expect(state.ownerId).toBe('owner-1');
      expect(state.currentValue).toBe(50);
      expect(state.history).toBeDefined();
      expect(Array.isArray(state.history)).toBe(true);
    });

    it('should create patience view model with qualitative info only', () => {
      const state: PatienceMeterState = {
        ownerId: 'owner-1',
        currentValue: 65,
        history: [],
        seasonStartValue: 50,
        lastWeekValue: 60,
        consecutiveDeclines: 0,
        consecutiveImprovements: 1,
      };

      const viewModel = createPatienceViewModel(state);

      expect(viewModel.status).toBeDefined();
      expect(viewModel.trend).toBeDefined();
      expect(viewModel.trendDescription).toBeDefined();
      expect(viewModel.isAtRisk).toBeDefined();
      expect(viewModel.urgencyLevel).toBeDefined();

      // Should not expose raw numeric value - check keys don't exist
      expect('currentValue' in viewModel).toBe(false);
      expect('numericValue' in viewModel).toBe(false);
    });
  });

  describe('Contract Management', () => {
    it('should create minimum contract correctly', () => {
      const contract = createMinimumContract(
        'player-1',
        'Test Player',
        'team-1',
        Position.QB,
        0, // rookie
        2025,
        3 // 3 years
      );

      expect(contract.id).toBeDefined();
      expect(contract.playerId).toBe('player-1');
      expect(contract.playerName).toBe('Test Player');
      expect(contract.teamId).toBe('team-1');
      expect(contract.position).toBe(Position.QB);
      expect(contract.totalYears).toBe(3);
      expect(contract.yearsRemaining).toBe(3);
    });

    it('should calculate dead money correctly', () => {
      const contract = createMinimumContract(
        'player-1',
        'Test Player',
        'team-1',
        Position.RB,
        2, // 2 years experience
        2023,
        4 // 4 years
      );

      const deadMoney = calculateDeadMoney(contract, 2025);

      // Dead money should be non-negative
      expect(deadMoney).toBeGreaterThanOrEqual(0);
    });

    it('should get cut breakdown with both options', () => {
      const contract = createMinimumContract(
        'player-1',
        'Test Player',
        'team-1',
        Position.WR,
        3,
        2023,
        4
      );

      const breakdown = getCutBreakdown(contract, 2025);

      expect(breakdown.standardCut).toBeDefined();
      expect(breakdown.postJune1Cut).toBeDefined();
      expect(breakdown.bestOption).toBeDefined();
      expect(breakdown.bestOptionReason).toBeDefined();

      // All cut options should have numeric values
      expect(typeof breakdown.standardCut.capSavings).toBe('number');
      expect(typeof breakdown.standardCut.deadMoney).toBe('number');
      expect(typeof breakdown.postJune1Cut.capSavings).toBe('number');
      expect(typeof breakdown.postJune1Cut.deadMoney).toBe('number');
    });

    it('should identify expiring contracts correctly', () => {
      const expiringContract = createMinimumContract(
        'player-1',
        'Expiring',
        'team-1',
        Position.TE,
        3,
        2025,
        1 // 1 year = expiring
      );

      const longContract = createMinimumContract(
        'player-2',
        'Long',
        'team-1',
        Position.TE,
        3,
        2025,
        4 // 4 years = not expiring
      );

      expect(isExpiringContract(expiringContract)).toBe(true);
      expect(isExpiringContract(longContract)).toBe(false);
    });
  });

  describe('Cross-Feature Type Compatibility', () => {
    it('should use consistent Position enum across features', () => {
      // Depth chart uses Position
      const depthEntry: DepthChartEntry = {
        position: Position.QB,
        playerId: 'player-1',
        depth: 1,
      };

      // Contract uses Position
      const contract = createMinimumContract('player-1', 'Test', 'team-1', Position.QB, 0, 2025, 1);

      // Both should have same position value
      expect(depthEntry.position).toBe(contract.position);
    });

    it('should maintain type safety for view models', () => {
      // Owner view model
      const owner = createDefaultOwner('owner-1', 'team-1');
      const ownerVM: OwnerViewModel = createOwnerViewModel(owner);
      expect(ownerVM.fullName).toBeDefined();

      // Patience view model
      const patienceState = createPatienceMeterState('owner-1', 50, 1, 1);
      const patienceVM: PatienceViewModel = createPatienceViewModel(patienceState);
      expect(patienceVM.status).toBeDefined();

      // These are separate view models but both come from owner data
      expect(ownerVM.jobSecurityStatus).toBeDefined();
      expect(patienceVM.isAtRisk).toBeDefined();
    });
  });
});
