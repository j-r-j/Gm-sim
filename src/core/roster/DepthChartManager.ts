/**
 * Depth Chart Manager
 * Manages team depth chart assignments and player rankings by position
 */

import { Player } from '../models/player/Player';
import {
  Position,
  OFFENSIVE_POSITIONS,
  DEFENSIVE_POSITIONS,
  SPECIAL_TEAMS_POSITIONS,
} from '../models/player/Position';
import { GameState } from '../models/game/GameState';

/**
 * Depth slot designation
 */
export type DepthSlot = 1 | 2 | 3;

/**
 * Individual depth chart entry
 */
export interface DepthChartEntry {
  position: Position;
  playerId: string;
  depth: DepthSlot;
}

/**
 * Complete team depth chart
 */
export interface DepthChart {
  teamId: string;
  entries: DepthChartEntry[];
  autoGenerated: boolean;
  lastUpdated: number;
}

/**
 * Position group for UI organization
 */
export interface PositionGroup {
  name: string;
  positions: Position[];
}

/**
 * Player with calculated overall rating for depth chart ranking
 */
export interface RankedPlayer {
  player: Player;
  overallRating: number;
  positionRating: number;
}

/**
 * Position depth view with players at each depth
 */
export interface PositionDepthView {
  position: Position;
  starter: Player | null;
  backup: Player | null;
  thirdString: Player | null;
}

// ============================================
// POSITION GROUPS
// ============================================

export const POSITION_GROUPS: PositionGroup[] = [
  {
    name: 'Offense',
    positions: OFFENSIVE_POSITIONS as Position[],
  },
  {
    name: 'Defense',
    positions: DEFENSIVE_POSITIONS as Position[],
  },
  {
    name: 'Special Teams',
    positions: SPECIAL_TEAMS_POSITIONS as Position[],
  },
];

/**
 * Get positions that need starters (offensive line collapsed)
 */
export const DEPTH_CHART_POSITIONS: Position[] = [
  // Offense
  Position.QB,
  Position.RB,
  Position.WR,
  Position.TE,
  Position.LT,
  Position.LG,
  Position.C,
  Position.RG,
  Position.RT,
  // Defense
  Position.DE,
  Position.DT,
  Position.OLB,
  Position.ILB,
  Position.CB,
  Position.FS,
  Position.SS,
  // Special Teams
  Position.K,
  Position.P,
];

// ============================================
// RATING CALCULATIONS
// ============================================

/**
 * Calculate overall player rating from technical skills
 * Uses perceived values (what GM sees) not true values
 */
export function calculatePlayerOverallRating(player: Player): number {
  const skills = player.skills;

  // Get skill value from skill object (use mid-point of perceived range)
  const getSkillValue = (skillName: string): number => {
    const skill = skills[skillName];
    if (!skill) return 50; // Default if skill not found
    return (skill.perceivedMin + skill.perceivedMax) / 2;
  };

  // Get position-specific skills
  const positionSkills = getPositionSkillNames(player.position);

  // Calculate average of all position-relevant skills
  let totalSkillValue = 0;
  let skillCount = 0;

  for (const skillName of positionSkills) {
    totalSkillValue += getSkillValue(skillName);
    skillCount++;
  }

  return skillCount > 0 ? Math.round(totalSkillValue / skillCount) : 50;
}

/**
 * Get relevant skill names for a position
 */
function getPositionSkillNames(position: Position): string[] {
  switch (position) {
    case Position.QB:
      return ['armStrength', 'accuracy', 'decisionMaking', 'pocketPresence', 'mobility'];
    case Position.RB:
      return ['vision', 'cutAbility', 'power', 'breakaway', 'catching'];
    case Position.WR:
      return ['routeRunning', 'catching', 'separation', 'yac'];
    case Position.TE:
      return ['blocking', 'routeRunning', 'catching', 'yac'];
    case Position.LT:
    case Position.LG:
    case Position.C:
    case Position.RG:
    case Position.RT:
      return ['passBlock', 'runBlock', 'awareness', 'footwork', 'power'];
    case Position.DE:
    case Position.DT:
      return ['passRush', 'runDefense', 'power', 'awareness'];
    case Position.OLB:
    case Position.ILB:
      return ['tackling', 'coverage', 'blitzing', 'pursuit', 'awareness'];
    case Position.CB:
    case Position.FS:
    case Position.SS:
      return ['manCoverage', 'zoneCoverage', 'tackling', 'ballSkills'];
    case Position.K:
      return ['kickPower', 'kickAccuracy', 'clutch'];
    case Position.P:
      return ['puntPower', 'puntAccuracy', 'hangTime'];
    default:
      return [];
  }
}

// ============================================
// DEPTH CHART GENERATION
// ============================================

/**
 * Generate depth chart for a team based on player ratings
 */
export function generateDepthChart(gameState: GameState, teamId: string): DepthChart {
  const team = gameState.teams[teamId];
  if (!team) {
    throw new Error(`Team ${teamId} not found`);
  }

  // Get all players on the team's roster
  const rosterPlayers = team.rosterPlayerIds
    .map((id) => gameState.players[id])
    .filter((p): p is Player => p !== undefined);

  const entries: DepthChartEntry[] = [];

  // For each position, rank players and assign depth
  for (const position of DEPTH_CHART_POSITIONS) {
    const positionPlayers = rosterPlayers.filter((p) => p.position === position);

    // Rank players at this position
    const rankedPlayers = positionPlayers
      .map((player) => ({
        player,
        overallRating: calculatePlayerOverallRating(player),
      }))
      .sort((a, b) => b.overallRating - a.overallRating);

    // Assign depth slots (up to 3 per position)
    for (let i = 0; i < Math.min(3, rankedPlayers.length); i++) {
      entries.push({
        position,
        playerId: rankedPlayers[i].player.id,
        depth: (i + 1) as DepthSlot,
      });
    }
  }

  return {
    teamId,
    entries,
    autoGenerated: true,
    lastUpdated: Date.now(),
  };
}

/**
 * Get players at a specific position with their depth
 */
export function getPositionDepth(
  gameState: GameState,
  depthChart: DepthChart,
  position: Position
): PositionDepthView {
  const positionEntries = depthChart.entries.filter((e) => e.position === position);

  const getPlayerAtDepth = (depth: DepthSlot): Player | null => {
    const entry = positionEntries.find((e) => e.depth === depth);
    return entry ? (gameState.players[entry.playerId] ?? null) : null;
  };

  return {
    position,
    starter: getPlayerAtDepth(1),
    backup: getPlayerAtDepth(2),
    thirdString: getPlayerAtDepth(3),
  };
}

/**
 * Get all position depths for a position group
 */
export function getPositionGroupDepths(
  gameState: GameState,
  depthChart: DepthChart,
  groupName: string
): PositionDepthView[] {
  const group = POSITION_GROUPS.find((g) => g.name === groupName);
  if (!group) return [];

  // Filter to depth chart positions only
  const positions = group.positions.filter((p) => DEPTH_CHART_POSITIONS.includes(p));

  return positions.map((position) => getPositionDepth(gameState, depthChart, position));
}

// ============================================
// DEPTH CHART MODIFICATIONS
// ============================================

/**
 * Move a player to a different depth slot
 */
export function movePlayerToDepth(
  depthChart: DepthChart,
  playerId: string,
  newDepth: DepthSlot
): DepthChart {
  const entry = depthChart.entries.find((e) => e.playerId === playerId);
  if (!entry) {
    throw new Error('Player not found in depth chart');
  }

  // Find current player at target depth
  const currentAtDepth = depthChart.entries.find(
    (e) => e.position === entry.position && e.depth === newDepth
  );

  // Swap if there's someone at that depth
  const updatedEntries = depthChart.entries.map((e) => {
    if (e.playerId === playerId) {
      return { ...e, depth: newDepth };
    }
    if (currentAtDepth && e.playerId === currentAtDepth.playerId) {
      return { ...e, depth: entry.depth };
    }
    return e;
  });

  return {
    ...depthChart,
    entries: updatedEntries,
    autoGenerated: false,
    lastUpdated: Date.now(),
  };
}

/**
 * Swap two players at a position
 */
export function swapPlayers(
  depthChart: DepthChart,
  playerId1: string,
  playerId2: string
): DepthChart {
  const entry1 = depthChart.entries.find((e) => e.playerId === playerId1);
  const entry2 = depthChart.entries.find((e) => e.playerId === playerId2);

  if (!entry1 || !entry2) {
    throw new Error('Players not found in depth chart');
  }

  if (entry1.position !== entry2.position) {
    throw new Error('Can only swap players at the same position');
  }

  const updatedEntries = depthChart.entries.map((e) => {
    if (e.playerId === playerId1) {
      return { ...e, depth: entry2.depth };
    }
    if (e.playerId === playerId2) {
      return { ...e, depth: entry1.depth };
    }
    return e;
  });

  return {
    ...depthChart,
    entries: updatedEntries,
    autoGenerated: false,
    lastUpdated: Date.now(),
  };
}

/**
 * Get starters for a team
 */
export function getStarters(gameState: GameState, depthChart: DepthChart): Player[] {
  return depthChart.entries
    .filter((e) => e.depth === 1)
    .map((e) => gameState.players[e.playerId])
    .filter((p): p is Player => p !== undefined);
}

/**
 * Get depth string for display
 */
export function getDepthLabel(depth: DepthSlot): string {
  switch (depth) {
    case 1:
      return 'Starter';
    case 2:
      return 'Backup';
    case 3:
      return '3rd String';
  }
}

/**
 * Get position display name
 */
export function getPositionDisplayName(position: Position): string {
  const names: Record<Position, string> = {
    QB: 'Quarterback',
    RB: 'Running Back',
    WR: 'Wide Receiver',
    TE: 'Tight End',
    LT: 'Left Tackle',
    LG: 'Left Guard',
    C: 'Center',
    RG: 'Right Guard',
    RT: 'Right Tackle',
    DE: 'Defensive End',
    DT: 'Defensive Tackle',
    OLB: 'Outside Linebacker',
    ILB: 'Inside Linebacker',
    CB: 'Cornerback',
    FS: 'Free Safety',
    SS: 'Strong Safety',
    K: 'Kicker',
    P: 'Punter',
  };
  return names[position] || position;
}

/**
 * Check if depth chart has all starting positions filled
 */
export function isDepthChartComplete(depthChart: DepthChart): boolean {
  const starterPositions = new Set(
    depthChart.entries.filter((e) => e.depth === 1).map((e) => e.position)
  );

  return DEPTH_CHART_POSITIONS.every((pos) => starterPositions.has(pos));
}

/**
 * Get missing starter positions
 */
export function getMissingStarters(depthChart: DepthChart): Position[] {
  const starterPositions = new Set(
    depthChart.entries.filter((e) => e.depth === 1).map((e) => e.position)
  );

  return DEPTH_CHART_POSITIONS.filter((pos) => !starterPositions.has(pos));
}
